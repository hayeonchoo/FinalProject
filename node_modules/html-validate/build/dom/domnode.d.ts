import { Location } from "../context";
import { NodeType } from "./nodetype";
import { DOMNodeCache } from "./cache";
export declare type DOMInternalID = number;
declare const TEXT_CONTENT: unique symbol;
declare module "./cache" {
    interface DOMNodeCache {
        [TEXT_CONTENT]: string;
    }
}
export declare function reset(): void;
export declare class DOMNode {
    readonly nodeName: string;
    readonly nodeType: NodeType;
    readonly childNodes: DOMNode[];
    readonly location: Location;
    readonly unique: DOMInternalID;
    private readonly cache;
    /**
     * Set of disabled rules for this node.
     *
     * Rules disabled by using directives are added here.
     */
    private disabledRules;
    /**
     * Create a new DOMNode.
     *
     * @param nodeType - What node type to create.
     * @param nodeName - What node name to use. For `HtmlElement` this corresponds
     * to the tagName but other node types have specific predefined values.
     * @param location - Source code location of this node.
     */
    constructor(nodeType: NodeType, nodeName: string, location?: Location);
    /**
     * Fetch cached value from this DOM node.
     *
     * @returns value or `undefined` if the value doesn't exist.
     */
    cacheGet<K extends keyof DOMNodeCache>(key: K): DOMNodeCache[K] | undefined;
    cacheGet(key: string | number | symbol): any | undefined;
    /**
     * Store a value in cache.
     *
     * @returns the value itself is returned.
     */
    cacheSet<K extends keyof DOMNodeCache>(key: K, value: DOMNodeCache[K]): DOMNodeCache[K];
    cacheSet<T>(key: string | number | symbol, value: T): T;
    /**
     * Remove a value by key from cache.
     */
    cacheRemove<K extends keyof DOMNodeCache>(key: K): boolean;
    cacheRemove(key: string | number | symbol): boolean;
    /**
     * Check if key exists in cache.
     */
    cacheExists<K extends keyof DOMNodeCache>(key: K): boolean;
    cacheExists(key: string | number | symbol): boolean;
    /**
     * Get the text (recursive) from all child nodes.
     */
    get textContent(): string;
    append(node: DOMNode): void;
    isRootElement(): boolean;
    /**
     * Returns a DOMNode representing the first direct child node or `null` if the
     * node has no children.
     */
    get firstChild(): DOMNode;
    /**
     * Returns a DOMNode representing the last direct child node or `null` if the
     * node has no children.
     */
    get lastChild(): DOMNode;
    /**
     * Disable a rule for this node.
     */
    disableRule(ruleId: string): void;
    /**
     * Disables multiple rules.
     */
    disableRules(rules: string[]): void;
    /**
     * Enable a previously disabled rule for this node.
     */
    enableRule(ruleId: string): void;
    /**
     * Enables multiple rules.
     */
    enableRules(rules: string[]): void;
    /**
     * Test if a rule is enabled for this node.
     */
    ruleEnabled(ruleId: string): boolean;
    generateSelector(): string | null;
}
export {};
