"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfig = void 0;
function createConfig(options) {
    const config = {
        root: true,
        extends: ["html-validate:recommended", "html-validate:document"],
        rules: {
            /* doctype is not passed when requesting source */
            "missing-doctype": "off",
            /* some frameworks (such as jQuery) often uses inline style, e.g. for
             * showing/hiding elements */
            "no-inline-style": "off",
            /* scripts will often add markup with trailing whitespace */
            "no-trailing-whitespace": "off",
            /* browser normalizes boolean attributes */
            "attribute-boolean-style": "off",
            "attribute-empty-style": "off",
            /* the browser will often do what it wants, out of users control */
            "void-style": "off",
            "no-self-closing": "off",
        },
    };
    if (options.legacyVoid) {
        config.rules.void = "off";
        delete config.rules["void-style"];
        delete config.rules["no-self-closing"];
    }
    return config;
}
exports.createConfig = createConfig;
/* istanbul ignore next: we dont test this logic with unittests, the createConfig is covered instead */
function canResolve(pkg) {
    try {
        require.resolve(pkg);
        return true;
    }
    catch (err) {
        return false;
    }
}
/* use legacy void rule if the new rules dont exist */
const haveVoidContent = canResolve("html-validate/build/rules/void-content") /* html-validate  < 4.x */ ||
    canResolve("html-validate/dist/rules/void-content"); /* html-validate >= 4.x */
const useLegacyVoid = !haveVoidContent;
exports.default = createConfig({
    legacyVoid: useLegacyVoid,
});
